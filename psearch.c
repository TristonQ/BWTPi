/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Description:                                                                *
 *                                                                             *
 * psearch.c for Assignment 3 of COMP9319, 14s1                                *
 * A position-couscious pwt searcher that expects 2/3 command line arguments:  *
 *    argv[1]-the pwt file to read;                                            *
 *    argv[2]-the string to search for, or                                     *
 *    argv[2]-beginning record number, argv[3]-ending record number            *
 * This program searches for a given pattern using a pwt encoded file and      *
 * return query results in the same order as they occur in original file.      *
 * The program applies bwt backward search to find matching pattern, then      *
 * forward decode until it reaches a '[', whose index in the pwt file is the   *
 * record number of the next record in the original file. The ordered query    *
 * results could be generated by sorting these record numbers and removing     *
 * duplicates.                                                                 *
 * Alternatively, this program can also return all records (delimited by '[')  *
 * from the starting record number to ending record number.                    *
 * 
 * Written by Lei Qian, 3447461                                                *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define ASCII 256
#define NEWLINE 10
#define NOT_EXIST -1
int original_file_size = 0;
int count_occ[ASCII] = {0};
int cumulative_occ[ASCII] = {0};
int chars_mapped = 0;
int chars_per_cell = 0;
int mapping[ASCII] = {0};

int *create_index(FILE *pwt);
void cumulate(int *occ, int *result);
int index_occ_given_char_and_position(FILE *pwt, int *index, unsigned char c, int position);
int find_position_given_occ(FILE *pwt, int *index, unsigned char query_char, int occ);
unsigned char find_char_in_F_given_position(int *cumulative_occ, int position);
int compare_record(const void *r1, const void *r2);
void output_record(FILE *pwt, int *, int record_number);


int main(int argc, char **argv) {
    FILE *pwt = fopen(argv[1], "rb");
    /* Create a bwt index similar to Assignment 2. */
    /* The size of index is constrained within 5MB so that it can fit in memory. */
    int *index = create_index(pwt);
    /* Calculate cumulative occurence and convert it into mapped form.
     * C[10] = 0, C[32] = 20, C[40] = 30, ...
     * mapping[10] = 0, mapping[32] = 1, mapping[40] = 2, ... ==>
     * C[0]  = 0, C[1]  = 20, C[2]  = 30, ...*/
    cumulate(count_occ, cumulative_occ);
    for (int i = 0; i < ASCII; ++i) {
        if (mapping[i] == -1)
            continue;
        cumulative_occ[mapping[i]] = cumulative_occ[i];
    }
    
    /* Search for a query string. */
    if (argc == 3) {
        int query_length = strlen(argv[2]);
        unsigned char query_char = argv[2][--query_length];
        /* If the last char has no occurrence in the pwt file, exit.  */
        if (mapping[query_char] == -1) {
            free(index);
            fclose(pwt);
            return EXIT_SUCCESS;
        }
        /* Find the upperbound and lowerbound of possible positions matching the last char. */
        int lower_position = cumulative_occ[mapping[query_char]];
        int upper_position;
        if (mapping[query_char] == chars_mapped - 1)
            upper_position = original_file_size - 1;
        else
            upper_position = cumulative_occ[mapping[query_char] + 1] - 1;
        /* Loop until the query string is exhausted and there are still possible matching positions. */
        while (query_length > 0 && lower_position <= upper_position) {
            
            /* Read the next backward char and determine possible upperbound and lowerbound. */
            query_char = argv[2][--query_length];
            if (mapping[query_char] == -1) {
                free(index);
                fclose(pwt);
                return EXIT_SUCCESS;
            }
            if (!lower_position)
                lower_position = cumulative_occ[mapping[query_char]];
            else
                lower_position = cumulative_occ[mapping[query_char]] +
                    index_occ_given_char_and_position(pwt, index, query_char, lower_position - 1);
            upper_position = cumulative_occ[mapping[query_char]] +
                index_occ_given_char_and_position(pwt, index, query_char, upper_position) - 1;
        }
        /* If there are candidate results for the query, output the records containing them. */
        if (lower_position <= upper_position) {
            int record_number[upper_position - lower_position + 1];
            int nb_of_records = 0;
            //bool *already_output = calloc(1, upper_position - lower_position + 1);
            for (int i = lower_position; i <= upper_position; ++i) {
                /* Given the position, find the corresponding char in first (sorted) column based on cumulative occurrences. */
                int occ;
                int current_position = i;
                unsigned char current_char = find_char_in_F_given_position(cumulative_occ, current_position);
                /* Locate the first '[' following the first char of query string and copy contents of the record following this char. */
                while (current_char != '[') {
                    occ = current_position + 1 - cumulative_occ[mapping[current_char]];
                    current_position = find_position_given_occ(pwt, index, current_char, occ);
                    current_char = find_char_in_F_given_position(cumulative_occ, current_position);
                }
                record_number[nb_of_records++] = (current_position + count_occ['['] - 1) % count_occ['['];
            }
            qsort(record_number, nb_of_records, sizeof(int), compare_record);
            /* Unpwt backward from the end of each record and output the result without duplicates. */
            output_record(pwt, index, record_number[0]);
            int last_number = record_number[0];
            for (int i = 1; i < nb_of_records; ++i)
                if (record_number[i] != last_number) {
                    output_record(pwt, index, record_number[i]);
                    last_number = record_number[i];
                }
        }
    }
    /* Output given records. */
    else if (argc == 4) {
        int start = atoi(argv[2]) - 1;
        int end = atoi(argv[3]) - 1;
        if (end > count_occ['['] - 1)
            end = count_occ['['] - 1;
        for (int i = start; i <= end; ++i)
            output_record(pwt, index, i);
    }
    free(index);
    fclose(pwt);
    return EXIT_SUCCESS;
}

/* Calculate the number of chars that are smaller than the current char. */
void cumulate(int *occ, int *result) {
    result[0] = occ['['];
    for (int i = 1; i < ASCII; ++i) {
        if (i == '[')
            result[i] = 0;
        else if (i == '[' + 1)
            result[i] = result[i - 2] + occ[i - 2];
        else
            result[i] = result[i - 1] + occ[i - 1];
    }
}


int *create_index(FILE *pwt) {
    int buffer_size = 1024 * 200;
    unsigned char *buffer = malloc(buffer_size);
    int bytes_read = 0;
    /* Count mapping and occurrences of chars for building index.
     * If chars 10, 32, 40, ... are present in pwt file, then
     * mapping[10] = 0, mapping[32] = 1, mapping[40] = 2,...
     * For any char x that is not contained in pwt file, mapping[x] = -1. */
    for (int c = 0; c < ASCII; ++c)
        mapping[c] = NOT_EXIST;
    while ((bytes_read = fread(buffer, 1, buffer_size, pwt)))
        for (int i = 0; i < bytes_read; ++i)
            count_occ[buffer[i]]++;
    for (int c = 0; c < ASCII; ++c)
        if (count_occ[c])
            mapping[c] = chars_mapped++;
    free(buffer);
    original_file_size = ftell(pwt);
    /* Given the available size of index file, calculate chars_per_cell and nb_of_cells.
     * The index file is expected to fit into RAM, so its size is capped at 5M. */
    int index_cell_size = chars_mapped * sizeof(int);
    int nb_of_cells = 5 * 1024 * 1024 / index_cell_size;
    if (nb_of_cells < 1)
        nb_of_cells = 1;
    else if (nb_of_cells > original_file_size)
        nb_of_cells = original_file_size;
    chars_per_cell = (original_file_size - 1) / nb_of_cells + 1;
    int *index = malloc(index_cell_size * nb_of_cells);
    
    /* Calculate occurences up to each cell and write to index. */
    fseek(pwt, 0, SEEK_SET);
    int *cell_occ_so_far = calloc(sizeof(int), chars_mapped);
    buffer = malloc(buffer_size);
    for (int i = 0; i < nb_of_cells; ++i) {
        bytes_read = fread(buffer, 1, chars_per_cell, pwt);
        for (int j = 0; j < bytes_read; ++j)
            cell_occ_so_far[mapping[buffer[j]]]++;
        if (bytes_read)
            memcpy(index + i * chars_mapped, cell_occ_so_far, index_cell_size);
    }
    free(buffer);
    free(cell_occ_so_far);
    return index;
}

/* Given an arbitrary char and position, return the occurrences
 * of this char up to this position in the pwt file. */
int index_occ_given_char_and_position(FILE *pwt, int *index, unsigned char c, int position) {
    if (mapping[c] == NOT_EXIST)
        return 0;
    int cell_number = position / chars_per_cell;
    int char_number = position % chars_per_cell;
    fseek(pwt, chars_per_cell * cell_number, SEEK_SET);
    unsigned char cell_containing_query_char[chars_per_cell];
    int actual_cell_size = fread(cell_containing_query_char, 1, chars_per_cell, pwt);
    int lowerbound_occ = 0;
    int upperbound_occ = 0;
    if (!cell_number)
        upperbound_occ = index[mapping[c]];
    else {
        lowerbound_occ = index[(cell_number - 1) * chars_mapped + mapping[c]];
        upperbound_occ = index[cell_number * chars_mapped + mapping[c]];
    }
    int offset = char_number + 1;
    if (lowerbound_occ == upperbound_occ)
        return lowerbound_occ;
    if (upperbound_occ - lowerbound_occ == actual_cell_size)
        return lowerbound_occ + offset;
    if (offset <= actual_cell_size / 2) {
        for (int i = 1; i <= offset; ++i) {
            if (cell_containing_query_char[i - 1] == c) {
                lowerbound_occ++;
                if (lowerbound_occ == upperbound_occ)
                    return lowerbound_occ;
            }
        }
        return lowerbound_occ;
    }
    offset = actual_cell_size - offset;
    for (int i = 1; i <= offset; ++i) {
        if (cell_containing_query_char[actual_cell_size - i] == c) {
            upperbound_occ--;
            if (lowerbound_occ == upperbound_occ)
                return upperbound_occ;
        }
    }
    return upperbound_occ;
}    

/* Given a char and its occurrence, find the position of the char with this occurrence. */
int find_position_given_occ(FILE *pwt, int *index, unsigned char c, int occ) {
    int lowerbound = 0;
    int upperbound = original_file_size - 1;
    int center = upperbound / 2;
    while (lowerbound < upperbound) {
        int calculated_occ = index_occ_given_char_and_position(pwt, index, c, center);
        if (calculated_occ < occ)
            lowerbound = center + 1;
        else if (calculated_occ == occ)
            upperbound = center;
        else
            upperbound = center - 1;
        center = (lowerbound + upperbound ) / 2;
    }
    return center;        
}

/* Given a position, determine which char it is in the F (sorted) column in pwt.*/
unsigned char find_char_in_F_given_position(int *cumulative_occ, int position) {
    if (position < count_occ['['])
        return '[';
    unsigned char c;
    for (c = ASCII - 1; c >= 0; --c) {
        if (mapping[c] == -1 || c == '[')
            continue;
        if (cumulative_occ[mapping[c]] <= position)
            return c;
    }
}

/* Compare which of the record numbers is larger. */
int compare_record(const void *r1, const void *r2) {
    if (*(int *)r1 > *(int *)r2)
        return 1;
    else if (*(int *)r1 < *(int *)r2)
        return -1;
    return 0;
}

/* Given record number, output the record. */
void output_record(FILE *pwt, int *index, int record_number) {
    /* Backward pwt from beginning of the next record. */
    int current_position = (record_number + 1) % count_occ['['];
    fseek(pwt, current_position, SEEK_SET);
    unsigned char current_char;
    fread(&current_char, 1, 1, pwt);
    unsigned char current_record[10000];
    int length = 0;
    while (current_char != '[') {
        current_record[length++] = current_char;
        current_position = cumulative_occ[mapping[current_char]] + index_occ_given_char_and_position(pwt, index, current_char, current_position) - 1;
        fseek(pwt, current_position, SEEK_SET);
        fread(&current_char, 1, 1, pwt);
    }
    /* Print out the record. */
    printf("[");
    for (int j = length - 1; j >= 0; --j)
        printf("%c", current_record[j]);
}
